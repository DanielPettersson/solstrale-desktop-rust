use std::collections::HashMap;
use std::error::Error;
use std::time::Duration;

use serde::{Deserialize, Serialize};
use solstrale::post::PostProcessors;
use solstrale::renderer::RenderImageStrategy;

use crate::model::post_processor::PostProcessor;
use crate::model::shader::Shader;
use crate::model::width_height::WidthHeight;
use crate::model::FieldType::{Optional, OptionalList};
use crate::model::{Creator, CreatorContext, DocumentationStructure, FieldInfo, HelpDocumentation};

#[derive(Serialize, Deserialize, PartialEq, Debug, Default)]
#[serde(deny_unknown_fields)]
pub struct RenderConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width_height: Option<WidthHeight>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub samples_per_pixel: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shader: Option<Shader>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub post_processors: Vec<PostProcessor>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preview_interval_ms: Option<u64>,
}

impl Creator<solstrale::renderer::RenderConfig> for RenderConfig {
    fn create(
        &self,
        ctx: &CreatorContext,
    ) -> Result<solstrale::renderer::RenderConfig, Box<dyn Error>> {
        let mut post_processors: Vec<PostProcessors> = Vec::new();

        for p in &self.post_processors {
            post_processors.push(p.create(ctx)?);
        }

        let (width, height) = self
            .width_height
            .as_ref()
            .unwrap_or(&WidthHeight::default())
            .create(ctx)?;

        let preview_interval = self.preview_interval_ms.unwrap_or(3000);

        Ok(solstrale::renderer::RenderConfig {
            width,
            height,
            samples_per_pixel: self.samples_per_pixel.unwrap_or(200),
            shader: self
                .shader
                .as_ref()
                .unwrap_or(&Shader::default())
                .create(ctx)?,
            post_processors,
            render_image_strategy: if preview_interval == 0 {
                RenderImageStrategy::EverySample
            } else {
                RenderImageStrategy::Interval(Duration::from_millis(preview_interval))
            },
        })
    }
}

impl HelpDocumentation for RenderConfig {
    fn get_documentation_structure(depth: u8) -> DocumentationStructure {
        DocumentationStructure {
            description: "General configuration for the renderer".to_string(),
            fields: HashMap::from([
                ("width_height".to_string(), FieldInfo::new(
                    "Width and height in pixels of the rendered output",
                    Optional,
                    WidthHeight::get_documentation_structure(depth + 1),
                )),
                ("samples_per_pixel".to_string(), FieldInfo::new_simple(
                    "Number of rays shot for each pixel. More rays gives less noisy image but takes longer time. Defaults to 200",
                    Optional,
                    "Count of rays shot per pixel",
                )),
                ("shader".to_string(), FieldInfo::new(
                    "A shader is responsible for coloring the pixels where a ray has hit an object. Defaults to a path tracing shader",
                    Optional,
                    Shader::get_documentation_structure(depth + 1),
                )),
                ("post_processors".to_string(), FieldInfo::new(
                    "A post processor is applied to the image after rendering for various effects",
                    OptionalList,
                    PostProcessor::get_documentation_structure(depth + 1),
                )),
                ("preview_interval_ms".to_string(), FieldInfo::new_simple(
                    "The minimum amount of milliseconds between preview images being generated by the renderer. Defaults to 3000",
                    Optional,
                    "Milliseconds between preview images",
                )),
            ]),
        }
    }
}
